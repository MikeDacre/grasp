#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
A Simple GRASP (grasp.nhlbi.nih.gov) API based on SQLAlchemy and Pandas

===============================================================================

        AUTHOR: Michael D Dacre, mike.dacre@gmail.com
  ORGANIZATION: Stanford University
       LICENSE: MIT License, property of Stanford, use as you wish
       CREATED: 2016-11-08
 Last modified: 2016-10-10 15:02

   DESCRIPTION: This is the front-end to a python grasp api, intended to allow
                easy database creation and simple querying.
                For most of the functions of this module, you will need to
                call the module directly.

===============================================================================
"""
from __future__ import print_function
import os
import sys
import readline
import argparse

from grasp import db
from grasp import config

try:
    input = raw_input
except NameError:
    pass

###############################################################################
#                                 Completion                                  #
###############################################################################


class tabCompleter(object):
    """
    A tab completer that can either complete from
    the filesystem or from a list.

    Taken from:
        https://gist.github.com/iamatypeofwalrus/5637895
    """

    def _listdir(self, root):
        "List directory 'root' appending the path separator to subdirs."
        res = []
        for name in os.listdir(root):
            path = os.path.join(root, name)
            if os.path.isdir(path):
                name += os.sep
            res.append(name)
        return res

    def _complete_path(self, path=None):
        "Perform completion of filesystem path."
        if not path:
            return os.listdir('.')
        path = os.path.expanduser(path)
        dirname, rest = os.path.split(path)
        tmp = dirname if dirname else '.'
        res = [os.path.join(dirname, p)
               for p in os.listdir(tmp) if p.startswith(rest)]
        # more than one match, or single match which does not exist (typo)
        if len(res) > 1 or not os.path.exists(path):
            return res
        # resolved to a single directory, so return list of files below it
        if os.path.isdir(path):
            return [os.path.join(path, p) for p in os.listdir(path)]
        # exact file match terminates this completion
        return [path + ' ']

    def pathCompleter(self, test, state):
        """
        This is the tab completer for systems paths.
        Only tested on *nix systems
        """
        line = readline.get_line_buffer()
        if not line:
            return self._complete_path('.')[state]
        else:
            return self._complete_path(line)[state]

    def createListCompleter(self,ll):
        """
        This is a closure that creates a method that autocompletes from
        the given list.

        Since the autocomplete function can't be given a list to complete from
        a closure is used to create the listCompleter function with a list to complete
        from.
        """
        def listCompleter(text,state):
            line   = readline.get_line_buffer()

            if not line:
                return [c + " " for c in ll][state]

            else:
                return [c + " " for c in ll if c.startswith(line)][state]

        self.listCompleter = listCompleter


###############################################################################
#                            Command Line Running                             #
###############################################################################


def main(argv=None):
    """Parse command line options to run as a script."""
    if not argv:
        argv = sys.argv[1:]

    parser  = argparse.ArgumentParser(
        description=__doc__,
        formatter_class=argparse.RawDescriptionHelpFormatter)

    subparsers = parser.add_subparsers(dest='modes')

    # Initialize the database
    init = subparsers.add_parser('init', help="Initialize the database")
    init.add_argument('db_file',
                      help="File to write the database to")
    init.add_argument('grasp_file', nargs='?',
                      help="GRASP tab delimeted file")
    init.add_argument('-p', '--progress', action='store_true',
                      help="Display a progress bar")

    # Initialize config
    conf = subparsers.add_parser('conf', aliases=['config'],
                                 help="Manage local config")
    cgrp = conf.add_mutually_exclusive_group()
    cgrp.add_argument('-i', '--init', dest='cinit', action='store_true',
                      help="Initialize the config with default settings.")
    cgrp.add_argument('-p', '--path', dest='cpath', action='store_true',
                      help="Display the path to the config file")

    args = parser.parse_args(argv)

    if args.modes == 'init':
        sys.stderr.write("Initializing\n")
        if os.path.exists(args.db_file):
            os.remove(args.db_file)
        grasp_file = args.grasp_file if args.grasp_file else sys.stdin
        db.initialize_database(grasp_file, dbfile=args.db_file,
                            progress=args.progress)
    elif args.modes == 'config':
        # Use tab completion
        t = tabCompleter()
        readline.set_completer_delims('\t')
        readline.parse_and_bind("tab: complete")
        if args.cinit:
            print("Do you want to initialize your config at {}"
                  .format(config.CONFIG_FILE))
            print("This will erase your current configuration (if it exists)")
            choice = input("Initialize config? [y/N] ").strip().lower()
            if not choice == 'y':
                return

            # Get choices with tab completion
            t.createListCompleter(["sqlite", "mysql", "postgresql"])
            readline.set_completer(t.listCompleter)
            print("What kind of database do you want to use?")
            db_type = input('sqlite/postgresql/mysql ').strip().lower()

            # Initialize for sqlite
            if db_type.lower() == 'sqlite':
                readline.set_completer(t.pathCompleter)
                print("Where would you like to put the db file?")
                file_path = os.path.expanduser(input('PATH: [~/grasp.db] ')).strip(' ').lower()
                if not file_path:
                    file_path = os.path.expanduser('~/grasp.db')
                host, user, passwd, host_string = '', '', '', ''

            # Initialize for other
            elif db_type.lower() == 'postgresql' or db_type.lower() == 'mysql':
                readline.set_completer()
                print("Your database needs to already be configured for "
                      "it to work. i.e. the user, password, and database need "
                      "to already exist. Please enter the required info below.")
                host = input('hostname [localhost]: ')
                host = host if host else 'localhost'
                user = input('username: ')
                passwd = input('password: ')
                file_path = ''
            else:
                print("Invalid db choice {}".format(db_type))
                return 1
            config.init_config(db_type, file_path, host, user, passwd)
        elif args.cpath:
            print("{}".format(config.CONFIG_FILE))
        else:
            config.print_help()
    else:
        parser.print_help()

if __name__ == '__main__' and '__file__' in globals():
    sys.exit(main())
