#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
A Simple GRASP (grasp.nhlbi.nih.gov) API based on SQLAlchemy and Pandas

===============================================================================

        AUTHOR: Michael D Dacre, mike.dacre@gmail.com
  ORGANIZATION: Stanford University
       LICENSE: MIT License, property of Stanford, use as you wish
       CREATED: 2016-11-08
 Last modified: 2016-10-12 16:57

   DESCRIPTION: This is the front-end to a python grasp api, intended to allow
                easy database creation and simple querying.
                For most of the functions of this module, you will need to
                call the module directly.

===============================================================================
"""
import os
import sys
import argparse

from grasp import db
from grasp import config


###############################################################################
#                            Command Line Running                             #
###############################################################################


def main(argv=None):
    """Parse command line options to run as a script."""
    if not argv:
        argv = sys.argv[1:]

    parser  = argparse.ArgumentParser(
        description=__doc__,
        formatter_class=argparse.RawDescriptionHelpFormatter)

    subparsers = parser.add_subparsers(dest='modes')

    # Initialize the database
    init = subparsers.add_parser('init', help="Initialize the database")
    init.add_argument('study_file',
                      help="GRASP study file from: " +
                      "github.com/MikeDacre/grasp/blob/master/grasp2_studies.txt")
    init.add_argument('grasp_file',
                      help="GRASP tab delimeted file")
    init.add_argument('-n', '--no-progress', action='store_false',
                      help="Do not display a progress bar")

    # Initialize config
    conf = subparsers.add_parser('conf', aliases=['config'],
                                 help="Manage local config")
    cgrp = conf.add_mutually_exclusive_group()
    cgrp.add_argument('--db', dest='cdb', metavar=None,
                      choices=['sqlite', 'postgresql', 'mysql'],
                      help="Set the current database platform.")
    cgrp.add_argument('--get-path', dest='cdpath', action='store_true',
                      help="Change the sqlite file path")
    cgrp.add_argument('--set-path', dest='cpath', metavar='PATH',
                      help="Change the sqlite file path")
    cgrp.add_argument('--init', dest='cinit', action='store_true',
                      help="Initialize the config with default settings. " +
                      "Will ERASE your old config!")

    args = parser.parse_args(argv)

    if args.modes == 'init':
        print("This will overwrite your existing database.")
        ans = input("Are you sure? [y/N] ")
        if not ans.lower() == 'y':
            return
        print("Initializing")
        db.initialize_database(args.study_file, args.grasp_file,
                               progress=args.no_progress)

    elif args.modes == 'config':
        if args.cdb:
            if not os.path.exists(config.CONFIG_FILE):
                print('Config does not exist, you must create it first.',
                      'Initializing config creation...')
                config.init_config_interactive()
            config.config['DEFAULT']['DatabaseType'] = args.cdb
            config.write_config()

        elif args.cinit:
            config.init_config_interactive()

        elif args.cdpath:
            print("{}".format(config.CONFIG_FILE))

        elif args.cpath:
            if not os.path.isfile(args.cpath):
                print("{} Does not exist.".format(args.cpath))
                ans = input('Use anyway? [y/N] ')
                if not ans == 'y':
                    return
            config.config['sqlite']['DatabaseFile'] = os.path.abspath(
                args.cpath
            )
            config.write_config()

        else:
            conf.print_help()
    else:
        parser.print_help()

if __name__ == '__main__' and '__file__' in globals():
    sys.exit(main())
